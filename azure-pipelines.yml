# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

variables:
  outputFolder: './_output'
  artifactsFolder: './_artifacts'
  testsFolder: './_tests'
  majorVersion: '0.6.2'
  minorVersion: $[counter(variables['build.reason'], 1000)]
  lidarrVersion: '$(majorVersion).$(minorVersion)'
  buildName: '$(Build.SourceBranchName).$(lidarrVersion)'
  windowsInstaller: 'Lidarr.$(buildName).windows-installer.exe'
  windowsZip: 'Lidarr.$(buildName).windows.zip'
  macOsApp: 'Lidarr.$(buildName).osx-app.zip'
  macOsTar: 'Lidarr.$(buildName).osx.tar.gz'
  linuxTar: 'Lidarr.$(buildName).linux.tar.gz'
  sentryOrg: 'lidarr'

trigger:
  branches:
    include:
    - develop

pr:
- develop

stages:
  - stage: Build_Backend
    displayName: Build Backend
          
    jobs:
    - job: Backend
      strategy:
        matrix:
          Linux:
            osName: 'Linux'
            imageName: 'ubuntu-16.04'
          Mac:
            osName: 'Mac'
            imageName: 'macos-10.13'
          Windows:
            osName: 'Windows'
            imageName: 'vs2017-win2016'

      pool:
        vmImage: $(imageName)
      steps:
      # Set the build name properly.  The 'name' property won't recursively expand so hack here:
      - powershell: Write-Host "##vso[build.updatebuildnumber]$($env:BUILDNAME)"
        displayName: Set Build Name
      - checkout: self
        submodules: true
      - task: Assembly-Info-NetFramework@2
        displayName: Patch AssemblyInfo
        inputs:
          Path: '$(Build.SourcesDirectory)'
          FileNames: 'src/NzbDrone.Common/Properties/SharedAssemblyInfo.cs'
          InsertAttributes: false
          FileEncoding: 'auto'
          WriteBOM: false
          VersionNumber: '$(lidarrVersion)'
          FileVersionNumber: '$(lidarrVersion)'
          InformationalVersion: '$(lidarrVersion)-rc1'
      - bash: ./build.sh --only-backend
        displayName: Build Lidarr Backend
      - publish: $(outputFolder)
        artifact: '$(osName)Backend'
        condition: and(succeeded(), eq(variables['osName'], 'Windows'))
      # - publish: $(Build.SourcesDirectory)
      #   artifact: 'CoverageBuild'
      #   condition: and(succeeded(), eq(variables['osName'], 'Windows'))
      - bash: |
          pwd
          ls -lR ./

      # Azure publish strips out permissions, so we have to tar / publish / dowload / untar
      - task: ArchiveFiles@2
        displayName: Create Test Package
        inputs:
          archiveFile: 'tests.tar.gz'
          archiveType: 'tar'
          tarCompression: 'gz'
          includeRootFolder: false
          rootFolderOrFile: $(testsFolder)
      - publish: tests.tar.gz
        artifact: LinuxTests
        condition: and(succeeded(), eq(variables['osName'], 'Linux'))
      - publish: $(testsFolder)
        artifact: '$(osName)Tests'
        condition: and(succeeded(), eq(variables['osName'], 'Windows'))

  - stage: Build_Frontend
    displayName: Build Frontend
    dependsOn: []
    
    jobs:
    - job: Frontend
      strategy:
        matrix:
          Linux:
            osName: 'Linux'
            imageName: 'ubuntu-16.04'
          Mac:
            osName: 'Mac'
            imageName: 'macos-10.13'
          Windows:
            osName: 'Windows'
            imageName: 'vs2017-win2016'
      pool:
        vmImage: $(imageName)
      steps:
      - task: NodeTool@0
        displayName: Set Node.js version
        inputs:
          versionSpec: '10.x'
      - checkout: self
        submodules: true
      - bash: ./build.sh --only-frontend
        displayName: Build Lidarr Frontend
        env:
          FORCE_COLOR: 0
      - publish: $(outputFolder)
        artifact: '$(osName)Frontend'
        condition: and(succeeded(), eq(variables['osName'], 'Windows'))
        
  - stage: Package
    dependsOn:
    - Build_Backend
    - Build_Frontend
    jobs:
    - job: Windows_Packages
      displayName: Create Packages
      pool:
        vmImage: 'vs2017-win2016'
      steps:
      - checkout: self
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: WindowsBackend
          targetPath: _output
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: WindowsFrontend
          targetPath: _output
      - bash: ./build.sh --only-packages
        displayName: Create Lidarr Packages
      - task: ArchiveFiles@2
        displayName: Create Windows zip
        inputs:
          archiveFile: '$(Build.ArtifactStagingDirectory)/$(windowsZip)'
          archiveType: 'zip'
          includeRootFolder: false
          rootFolderOrFile: $(artifactsFolder)/windows
      - task: ArchiveFiles@2
        displayName: Create MacOS app
        inputs:
          archiveFile: '$(Build.ArtifactStagingDirectory)/$(macOsApp)'
          archiveType: 'zip'
          includeRootFolder: false
          rootFolderOrFile: $(artifactsFolder)/macos-app
      - task: ArchiveFiles@2
        displayName: Create MacOS tar
        inputs:
          archiveFile: '$(Build.ArtifactStagingDirectory)/$(macOsTar)'
          archiveType: 'tar'
          tarCompression: 'gz'
          includeRootFolder: false
          rootFolderOrFile: $(artifactsFolder)/macos
      - task: ArchiveFiles@2
        displayName: Create Linux tar
        inputs:
          archiveFile: '$(Build.ArtifactStagingDirectory)/$(linuxTar)'
          archiveType: 'tar'
          tarCompression: 'gz'
          includeRootFolder: false
          rootFolderOrFile: $(artifactsFolder)/linux
      - bash: |
          ./setup/inno/ISCC.exe "./setup/lidarr.iss"
          cp ./setup/output/Lidarr.*windows.exe ${BUILD_ARTIFACTSTAGINGDIRECTORY}/${WINDOWSINSTALLER}
        displayName: Create Windows installer
      - publish: $(Build.ArtifactStagingDirectory)
        artifact: 'Packages'
      - bash: |
          echo "Uploading source maps to sentry"
          yarn sentry-cli releases new --finalize -p lidarr -p lidarr-ui -p lidarr-update "${LIDARRVERSION}-debug"
          yarn sentry-cli releases -p lidarr-ui files "${LIDARRVERSION}-debug" upload-sourcemaps _output/UI/ --rewrite
          yarn sentry-cli releases set-commits --auto "${LIDARRVERSION}-debug"
          yarn sentry-cli releases deploys "${LIDARRVERSION}-debug" new -e nightly
        displayName: Publish Sentry Source Maps
        condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
        env:
          SENTRY_AUTH_TOKEN: $(sentryAuthToken)
    
  - stage: Unit_Test
    displayName: Unit Tests
    dependsOn: Build_Backend
    condition: succeeded()
    jobs:
    - job: Unit
      strategy:
        matrix:
          Linux:
            osName: 'Linux'
            imageName: 'ubuntu-16.04'
          Mac:
            osName: 'Mac'
            imageName: 'macos-10.13'
          Windows:
            osName: 'Windows'
            imageName: 'vs2017-win2016'

      pool:
        vmImage: $(imageName)

      steps:
      - checkout: none
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: WindowsTests
          targetPath: $(testsFolder)
      - bash: |
          wget https://github.com/acoustid/chromaprint/releases/download/v1.4.3/chromaprint-fpcalc-1.4.3-linux-x86_64.tar.gz
          sudo tar xf chromaprint-fpcalc-1.4.3-linux-x86_64.tar.gz --strip-components=1 --directory /usr/bin
        displayName: Install fpcalc
        condition: and(succeeded(), eq(variables['osName'], 'Linux'))
      - powershell: Set-Service SCardSvr -StartupType Manual
        condition: and(succeeded(), eq(variables['osName'], 'Windows'))
      - bash: |
          chmod a+x _tests/fpcalc
          export DYLD_FALLBACK_LIBRARY_PATH=${BUILD_SOURCESDIRECTORY}/_tests
        condition: and(succeeded(), eq(variables['osName'], 'Mac'))
      - task: Bash@3
        displayName: Run Tests
        env:
          DYLD_FALLBACK_LIBRARY_PATH: $(Build.SourcesDirectory)/_tests
        inputs:
          targetType: 'filePath'
          filePath: '$(testsFolder)/test.sh'
          arguments: '$(osName) Unit Test'
      # - bash: $(testsFolder)/test.sh $(osName) Unit Test
      #   env:
      #     DYLD_FALLBACK_LIBRARY_PATH: $(Build.SourcesDirectory)/_tests
      - task: PublishTestResults@2
        displayName: Publish Test Results
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: '$(osName) Unit Tests'

    # - job: Windows_Unit_Tests
    #   displayName: Windows Unit
    #   pool:
    #     vmImage: 'vs2017-win2016'
    #   steps:
    #   - checkout: self
    #   - task: DownloadPipelineArtifact@2
    #     displayName: Download Test Artifact
    #     inputs:
    #       buildType: 'current'
    #       artifactName: Tests
    #       targetPath: $(testsFolder)
    #   - task: Bash@3
    #     displayName: Windows Unit Tests
    #     inputs:
    #       targetType: 'filePath'
    #       filePath: ./test.sh
    #       arguments: Windows Unit Test
    #   - task: PublishTestResults@2
    #     inputs:
    #       testResultsFormat: 'NUnit'
    #       testResultsFiles: '**/TestResult.xml'
    #       testRunTitle: 'Windows Unit Tests'

    # - job: Mac_Unit_Tests
    #   displayName: macOS Unit
    #   pool:
    #     vmImage: 'macOS-10.13'
    #   steps:
    #   - checkout: self
    #   - task: DownloadPipelineArtifact@2
    #     displayName: Download Test Artifact
    #     inputs:
    #       buildType: 'current'
    #       artifactName: Tests
    #       targetPath: $(testsFolder)
    #   - task: Bash@3
    #     displayName: macOS Unit Tests
    #     inputs:
    #       targetType: 'filePath'
    #       filePath: ./test.sh
    #       arguments: Mac Unit Test
    #   - task: PublishTestResults@2
    #     inputs:
    #       testResultsFormat: 'NUnit'
    #       testResultsFiles: '**/TestResult.xml'
    #       testRunTitle: 'macOS Unit Tests'

  - stage: Integration_Automation
    displayName: Integration / Tests
    dependsOn: Package
    jobs:
    
    - job: Linux_Integration_Tests
      displayName: Linux Integration
      pool:
        vmImage: 'ubuntu-16.04'
      steps:
      - script: |
          wget https://github.com/acoustid/chromaprint/releases/download/v1.4.3/chromaprint-fpcalc-1.4.3-linux-x86_64.tar.gz
          sudo tar xf chromaprint-fpcalc-1.4.3-linux-x86_64.tar.gz --strip-components=1 --directory /usr/bin
        displayName: Install fpcalc
      - checkout: self
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: WindowsTests
          targetPath: $(testsFolder)
      - task: DownloadPipelineArtifact@2
        displayName: Download Build Artifact
        inputs:
          buildType: 'current'
          artifactName: Packages
          itemPattern: '**/Lidarr.**.linux.tar.gz'
          targetPath: $(Build.ArtifactStagingDirectory)
      - task: ExtractFiles@1
        inputs:
          archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/**/Lidarr.**.linux.tar.gz' 
          destinationFolder: '$(Build.ArtifactStagingDirectory)/bin'
      - bash: |
          mkdir ./bin
          cp -R -v ${BUILD_ARTIFACTSTAGINGDIRECTORY}/bin/Lidarr/* ./bin
      - task: Bash@3
        displayName: Linux Integration Tests
        inputs:
          targetType: 'filePath'
          filePath: ./test.sh
          arguments: Linux Integration Test
      - task: PublishTestResults@2
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: 'Linux Integration Tests'


    - job: Windows_Integration_Tests
      displayName: Windows Integration
      pool:
        vmImage: 'vs2017-win2016'
      steps:
      - checkout: self
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: WindowsTests
          targetPath: $(testsFolder)
      - task: DownloadPipelineArtifact@2
        displayName: Download Build Artifact
        inputs:
          buildType: 'current'
          artifactName: Packages
          itemPattern: '**\Lidarr.**.windows.zip'
          targetPath: $(Build.ArtifactStagingDirectory)
      - task: ExtractFiles@1
        inputs:
          archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/**/Lidarr.**.windows.zip' 
          destinationFolder: '$(Build.ArtifactStagingDirectory)/bin'
      - bash: |
          mkdir -p ./bin/
          cp -r -v ${BUILD_ARTIFACTSTAGINGDIRECTORY}/bin/Lidarr/. ./bin/
      - task: Bash@3
        displayName: Windows Integration Tests
        inputs:
          targetType: 'filePath'
          filePath: ./test.sh
          arguments: Windows Integration Test
      - task: PublishTestResults@2
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: 'Windows Integration Tests'

    - job: Windows_Automation_Tests
      displayName: Windows Automation
      pool:
        vmImage: 'vs2017-win2016'
      steps:
      - checkout: self
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: WindowsTests
          targetPath: $(testsFolder)
      - task: DownloadPipelineArtifact@2
        displayName: Download Build Artifact
        inputs:
          buildType: 'current'
          artifactName: Packages
          itemPattern: '**\Lidarr.**.windows.zip'
          targetPath: $(Build.ArtifactStagingDirectory)
      - task: ExtractFiles@1
        inputs:
          archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/**/Lidarr.**.windows.zip' 
          destinationFolder: '$(Build.ArtifactStagingDirectory)/bin'
      - bash: |
          mkdir -p ./bin/
          cp -r -v ${BUILD_ARTIFACTSTAGINGDIRECTORY}/bin/Lidarr/. ./bin/
      - task: Bash@3
        displayName: Windows Automation Tests
        inputs:
          targetType: 'filePath'
          filePath: ./test.sh
          arguments: Windows Automation Test
      - task: PublishTestResults@2
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: 'Windows Automation Tests'


  - stage: Coverage
    dependsOn: Build_Backend
    condition: succeeded()
    jobs:
    - job: Windows_Coverage
      displayName: Windows
      pool:
        vmImage: 'vs2017-win2016'
      steps:
      - checkout: self
        submodules: true
      #- bash: ./build.sh --only-backend
      #  displayName: Build Lidarr Backend
      # - task: DownloadPipelineArtifact@2
      #   inputs:
      #     buildType: 'current'
      #     artifactName: CoverageBuild
      #     targetPath: $(Build.SourcesDirectory)
      #- publish: $(testsFolder)
      #  artifact: 'CoverageTest'
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: WindowsTests
          targetPath: $(testsFolder)
      - bash: |
          pwd
          ls -lR ./
      - task: Bash@3
        displayName: Coverage Unit Tests
        inputs:
          targetType: 'filePath'
          filePath: ./test.sh
          arguments: Windows Unit Coverage
      - task: PublishCodeCoverageResults@1
        displayName: Publish Coverage Results
        inputs:
          codeCoverageTool: 'cobertura'
          summaryFileLocation: './Coverage.xml'

    - job: Linux_Coverage
      displayName: Linux
      pool:
        vmImage: 'ubuntu-16.04'
      steps:
      - checkout: self
        submodules: true
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: LinuxTests
          targetPath: '$(Build.SourcesDirectory)'
      - bash: |
          pwd
          ls -lR ./
      - task: ExtractFiles@1
        inputs:
          archiveFilePatterns: tests.tar.gz
          destinationFolder: _tests
      - bash: |
          pwd
          ls -lR ./
      - bash: ./test.sh Linux Unit Coverage
        displayName: Coverage Unit Tests
      # - task: Bash@3
      #   displayName: Coverage Unit Tests
      #   inputs:
      #     targetType: 'filePath'
      #     filePath: ./test.sh
      #     arguments: Linux Unit Coverage
      - task: PublishCodeCoverageResults@1
        displayName: Publish Coverage Results
        inputs:
          codeCoverageTool: 'cobertura'
          summaryFileLocation: './Coverage.xml'
